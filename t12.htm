<!DOCTYPE html><html lang="ru" dir="ltr" spellcheck><head><!--#include file="h.htm"--><meta name="description" content="Пиццикато Алексея Лота. Полезные высказывания из книги 'Рефакторинг. Улучшение существующего кода' Фаулера."><meta name="keywords" content="сайт алексея лота, технологии, рефакторинг, улучшение кода, фаулера, правила разработки, программного обеспечения, алексей лот"><title>Полезные высказывания из книги "Рефакторинг. Улучшение существующего кода" Фаулера</title></head><body><header><h1 class=m>Пиццикато Алексея Лота</h1><nav><a href="p.htm">Главная</a><a href="a.htm">Афоризмы</a><a href="m.htm">Песни</a><a href="l.htm">Психология</a><a href="r.htm">Рассказы</a><a href="b.htm">Религия</a><a href="s.htm">Стихотворения</a><a id="i" href="t.htm">Технологии</a><a href="f.htm">Философия</a></nav></header><article id="c"><h2 class=m>Полезные высказывания из книги "Рефакторинг. Улучшение существующего кода" Фаулера</h2><div id="w">Рефакторинг (refactoring) - изменение во внутренней структуре программного обеспечения, имеющие целью облегчить понимание его работы и упростить модификацию, не затрагивая наблюдаемого поведения.<br><br>Производить рефакторинг (refactor) - изменять структуру программного обеспечения, применяя ряд рефакторингов, не затрагивая его поведения.<br><br>Рефакторинг предоставляет технологию приведения кода в порядок, осуществляемую в более эффективном и управляемом стиле.<br><br>При каждой возможности проводить тестирование.<br><br>Цель рефакторинга - упростить понимание и модификацию ПО.<br><br>Оптимизация производительности часто затрудняет понимание кода.<br><br>Рефакторинг не меняет видимого поведения ПО.<br><br>Рефакторинг улучшает композицию ПО.<br><br>Изменение размера образа программы в памяти редко имеет значение.<br><br>Удаление дублирующегося кода улучшает композицию.<br><br>Рефакторинг облегчает понимание ПО.<br><br>Рефакторинг делает код легким для чтения.<br><br>Рефакторинг позволяет увидеть в коде больший объем системы.<br><br>Рефакторинг помогает найти ошибки.<br><br>Рефакторинг ускоряет понимание программ.<br><br>Рефакторингом следует заниматься постоянно понемногу.<br><br>Сначала необходимость рефакторинга будет неприятна.<br><br>Чаще всего рефакторинг начинается с необходимости добавления в ПО новой функции.<br><br>Рефакторинг - процесс быстрый и ровный.<br><br>Получение сообщения об ошибке - причина провести рефакторинг.<br><br>Проводить рефакторинг при разборе кода.<br><br>Рефакторинг облегчает модификацию.<br><br>Рефакторинг способствует получению более конкретных результатов от разбора кода.<br><br>Использовать UML и CRC-карты при разборе дизайна кода.<br><br>Рефакторинг разделяет большие объекты на несколько меньших<br>.<br>Благодаря помещению отдельного программного слоя между объектной моделью и моделью базы данных можно отделить модификации двух разных моделей друг от друга.<br><br>Если изменяемый интерфейс используется недоступным для изменения кодом, то из старого интерфейса вызывать новый, пометив старый как устаревший.<br><br>Не нужно предоставлять интерфейсы, которые не требуются.<br><br>Не публиковать интерфейсы раньше срока.<br><br>Определять родительский класс исключения для пакета в целом.<br><br>Представлять себе возможный рефакторинг.<br><br>Перед началом рефакторинга код должен выполняться в основном корректно, иначе - переписать код с нуля.<br><br>Рефакторинг должен подразумевать его завершение.<br><br>Окончание проекта может быть причиной отложения рефакторинга.<br><br>Программа весьма отличается от физического механизма.<br><br>Рефакторинг может быть полной заменой предварительному проектированию.<br><br>При рефакторинге от предварительного проектирования требуется приемлемое решение, а не единственно правильное.<br><br>Гибкие решения сложнее обычных.<br><br>Даже если точно известно устройство системы, не заниматься гаданием, а провести замеры.<br><br>Секрет создания быстрых программ: написать настраиваемую программу, а затем настроить так, чтобы достичь приемлемой скорости.<br><br>Подходы написания быстрых программ:<br>при декомпозиции каждому компоненту выделяется бюджет ресурсов - по времени и памяти; компонент не выходит за рамки бюджета, хотя разрешен обмен ресурсами;<br>постоянное внимание и попытки программиста сделать систему производительнее.<br><br>Если в равной мере оптимизировать весь код, то 90% оптимизации будет произведено впустую.<br><br>Большая часть времени расходуется небольшой частью кода.<br><br>Запуск в конце разработки профайлера и выявление затратных компонентов.<br><br>Рефакторинг выигрывает время для оптимизации.<br><br>Рефакториг обеспечивает более высокое разрешение для анализа производительности.<br><br>Рефакторинг возник в 80-х.<br><br>Одно и то же выражение в двух методах одного класса - необходимо выделение метода.<br><br>Одно и то же выражение в подклассах одного уровня - необходимо выделение метода с последующим подъемом поля.<br><br>Если код похож, но не совпадает полностью, нужно применить выделение метода для отделения совпадающих фрагментов от различающихся, затем проверить применимость формирования шаблона метода.<br><br>Если два метода делают одно и то же с помощью разных алгоритмов, можно выбрать более четкий из алгоритмов и применить замещение алгоритма.<br><br>Если дублирующийся код находится в двух разных классах, попробовать применить выделение классов в одном классе, а затем использовать новый компонент в другом.<br><br>Следует активнее применять декомпозицию методов.<br><br>В 99% случаев, чтобы укоротить метод, требуется лишь выделение метода.<br><br>Устранить временные переменные метода заменой временной переменной вызовом метода.<br><br>Длинные списки параметров метода сокращать введением граничного объекта, сохранением всего объекта.<br><br>Если не удалось удалить все лишние временные переменные и параметры, применить замену метода объектом метода.<br><br>Даже одну строку имеет смысл выделитьв метод, если она нуждается в комментарии.<br><br>Для условных выражений делать выделение с помощью декомпозиции условных операторов.<br><br>Содержащийся в цикле код - отдельный метод.<br><br>При большом числе атрибутов класса применять выделение класса.<br><br>Одинаковые префиксы или суффиксы подмножества переменных - необходимость создания компонента.<br><br>Для создания компонента как подкласса использовать выделение подкласса.<br><br>Если класс не использует постоянно все переменные своего экземпляра - применить выделение класса и выделение подкласса несколько раз.<br><br>Для класса с чрезмерным объемом кода применить выделение класса или выделение подкласса, а для дальнейшего разделения - применить выделение интерфейса и выявить ещё части.<br><br>При необходимости хранения копий некоторых данных в двух местах и обеспечения их согласованности применить дублирование видимых данных.<br><br>Класс GUI выделить с его данными и поведением в отдельный объект предметной области.<br><br>Работая с объектами, следует передавать методу не все, а столько, чтобы он мог добраться до всех необходимых ему данных.<br><br>Для получения данных в одном параметре путем вызова метода применитьзамену параметра вызовом метода объекта, который уже известен.<br><br>Чтобы группу данных, полученных от объекта, заменить самим объектом, применить сохранение всего объекта.<br><br>Если есть несколько элементов данных без логического объекта, применить введение граничного объекта.<br><br>Если не нужно создавать зависимость между вызываемым и крупным объектом, можно передавать все в параметрах.<br><br>Если класс часто модифицируется различными способами по разным причинам, необходимо разбиение на классы.<br><br>Определить, что изменяется по одной причине в классе, и применить выделение класса.<br><br>Когда при выполнении любых модификаций приходится модифицировать множество классов с небольшими изменениями, применить перемещение метода, перемещение поля, чтобы свести все изменения в один класс.<br><br>Чтобы поместить связку методов в один класс, использовать встраивание класса.<br><br>Если метод больше интересуется не тем классом, в котором он находится применить перемещение метода или выделение метода для части кода этого метода.<br><br>Если метод использует функции нескольких классов, то разбить его выделением метода.<br><br>То, что изменяется одновременно, надо хранить в одном месте (для исключений - паттерны стратегия и посетитель).<br><br>Связки данных, встречающихся совместно, надо превращать в самостоятельный класс: сначала найти эти группы в виде полей, применить к ним выделение метода (в отдельный класс), затем к сигнатурам методов применить введение граничного объекта или сохранение всего объекта.<br><br>Элементарные типы убирать применением замены значения данных объектом или замену кода типа классом.<br><br>Для условных операторов, зависящих от кода типа, применять замену кода типа подклассами или замену кода типа состоянием, стратегией.<br><br>При наличии группы полей, которые должны находиться вместе, применять выделение класса.<br><br>Для примитивов в типах параметров применять введение граничного объекта.<br><br>Если обнаружена разборка на части массива, применить замену массива объектом.<br><br>Для выделения переключателя switch использовать выделение метода, затем перемещение метода, затем пробовать применить замену кода типа подклассами, замену кода типа состоянием или стратегией, замену условного оператора полиморфизмом.<br><br>Если есть лишь несколько вариантов переключателя, управляющих одним методом, и не предполагается их изменение, применить замену параметра явными методами.<br><br>Если одним из вариантов является null, применить введение объекта Null.<br><br>Чтобы заставить экземпляры одной иерархии ссылаться на экземпляры другой, применить перемещение меода и перемещение поля.<br><br>При наличии подклассов с недостаточными функциями применить свертывание иерархии, встраивание класса.<br><br>Если есть аабстрактные классы, не приносящие большой пользы, применить сворачивание иерархии.<br><br>Ненужное делегирование можно устранить с помощью встраивания класса.<br><br>К методам с неиспользуемыми параметрами применить удаление параметров.<br><br>К методам со странными абстрактными именами применить переименование метода.<br><br>Для непонятных переменных применять выделение класса.<br><br>Условно выполняемый код удалить, применив введение объекта Null.<br><br>Для алгоритма, использующего несколько переменных, применить выделение класса.<br><br>Для цепочки сообщений применить сокрытие делегирования (для конечного объекта можно применить выделение метода, перемещение метода и передвинуть использующий его код вниз по цепочке).<br><br>Для интерфейса, в котором половина методов делегирует обработку другому классу, применить удаление посредника.<br><br>При наличии нескольких методов, не выполняющих большой работы, применить встраивание метода и поместить в вызывающий метод.<br><br>Посредника преобразовать в подкласс реального класса можно заменой делегирования наследованием.<br><br>С помощью перемещения метода и перемещения поля можно разделить части и уменьшить близость классов, затем применить замену двунаправленной связи однонаправленной, выделением класса, сокрытием делегирования.<br><br>При чрезмерном наследовании применить замену наследования делегированием.<br><br>Ко всем методам, выполняющим одинаковые действия по различающимся сигнатурам, применить переименование метода, перемещение метода, выделение родительского класса.<br><br>Если в библиотечный класс нужно включить 1-2 новых метода, то применить введение внешнего метода.<br><br>Если в библиотечный класс нужно включить много новых методов - применить введение локального расширения.<br><br>К открытым полям классов применить инкапсуляцию поля.<br><br>К открытым полям коллекций применить инкапсуляцию коллекций.<br><br>Ко всем полям, значение которых не должно изменяться, применить удаление метода установки значения.<br><br>Методы доступа переместить в класс данных, применив перемещение метода, выделение метода.<br><br>К методам получения и установки значений полей применить сокрытие метода.<br><br>При неправильной иерархии наследования применить спуск метода, спуск поля, создав новый класс на одном уровне с потомком, вытолкнуть в него бездействующие методы.<br><br>Можно делать все родительские классы абстрактными.<br><br>Для разрушения иерархии при неиспользовании интерфейса родительского класса применить замену наследования делегированием.<br><br>Чтобы избавиться от комментариев к блоку, использовать выделение метода, переименование метода, введение утверждения.<br><br>Перед рефакторингом должны быть созданы тесты.<br><br>В каждом классе должен быть свой метод, с помощью которого он может себя протестировать.<br><br>Тестовые данные - test fixture.<br><br>Проверять, действительно ли тест проверяет то, что требуется.<br><br>Получив сообщение об ошибке, начать с тести модуля, показывающего её.<br><br>Тестировать те области, возможность ошибок в которых выше.<br><br>Проверять, что ожидаемые ошибки происходят в надлежащем порядке.<br><br>Проверять тестами границы.<br><br>Для представления денежных величин использовать паттерн количество.<br><br>Выделение метода и другие рефакторинги - смотреть по шагам в приложении книги.<br></div></article><br><footer>&copy;&nbsp;<i>Copyright&nbsp;<a href="https://алексейлот.рф">алексейлот.рф</a>&nbsp;-&nbsp;возьми главную ноту</i></footer></body></html>
